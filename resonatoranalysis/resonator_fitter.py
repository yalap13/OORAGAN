import os
import lmfit
import numpy as np

from pathlib import Path
from resonator import background, shunt, reflection
from resonator.base import BackgroundModel
from numpy.typing import ArrayLike, NDArray
from typing import Optional
from lmfit import Parameter

from .dataset import Dataset
from .util import convert_complex_to_magphase, convert_magphase_to_complex, choice
from .analysis import dict_filler, plot_fit, lst_to_arrays


class ResonatorFitter:
    """
    Resonator fitting object

    Parameters
    ----------
    dataset : Dataset
        Dataset of the data to fit.
    """

    def __init__(self, dataset: Dataset):
        self.dataset = dataset
        if self.dataset.format == "magphase":
            self.dataset.convert_magphase_to_complex()

    def fit(
        self,
        file_index: int | list[int] = [],
        power: float | list[float] = [],
        f_r: float = None,
        couploss: float = 1e-6,
        intloss: float = 1e-6,
        bg: BackgroundModel = background.MagnitudePhaseDelay(),
        savepic: bool = False,
        savepath: str = "",
        write: bool = False,
        basepath: str = os.getcwd(),
        threshold: float = 0.5,
        start: int = 0,
        jump: int = 10,
        nodialog: bool = False,
    ):
        """
        Fitting specified resonator data.

        Parameters
        ----------
        file_index : int or list of int, optional
            Index or list of indices of files (as displayed in the Dataset table) for
            which to fit the data. Defaults to ``[]`` which fits data for all files.
        power : float or list of float, optional
            If specified, will fit data for those power values.
            Defaults to ``[]`` which fits for all power values.
        savepath : str, optional
            Where to save the graph, savepic must be True. The default is "".
        savepic : bool, optional
            If True, saves the fit plots generated by the function in the Images folder in the same
            directory. The default is False.
        write : bool, optional
            Choose whether to write the fit results in a .txt file in the Fit results folder in the
            same directory or not. The default is False.
        f_r : int, optional
            Value of resonance frequency, adds to fit parameters. The default is None.
        couploss : int, optional
            Coupling loss of resonator, adds to fit parameters. The default is 1e6.
        intloss : int, optional
            Internal loss of resonator, adds to fit parameters. The default is 1e6.
        threshold : float, optional
            A value greater than 0 which determine the error tolerance on fit values.
            The default is 1 (100%).
        bg : class-like object, optional
            Background model from resonator library. The default is background.MagnitudePhaseDelay().
        start : int, optional
            Where to start shrunking dataset. The default is 0.
        jump : int, optional
            Step between the shrunking of dataset to fit better. The default is 10.
        nodialog : bool, optional
            If True, does not display any dialog box (watch out for overwriting). The default is False.
        """
        if savepic and not os.path.exists(os.path.join(savepath, "images")):
            os.mkdir(os.path.join(savepath, "images"))
        if write and not os.path.exists(os.path.join(savepath, "fit_results")):
            os.mkdir(os.path.join(savepath, "fit_results"))

        params = lmfit.Parameters()
        params.add(name="internal_loss", value=intloss)
        params.add(name="coupling_loss", value=couploss)
        params.add(name="resonance_frequency", value=f_r, min=1e9, max=1e10)

        sliced_dataset = self.dataset.slice(file_index=file_index, power=power)
        if isinstance(sliced_dataset.files, str):
            ...
        else:
            ...

        dictoflist = {}
        dictio, r = {}, {}
        data_store = {
            "Q_c": [],
            "Q_c_err": [],
            "Q_i": [],
            "Q_i_err": [],
            "Q_t": [],
            "Q_t_err": [],
            "L_c": [],
            "L_c_err": [],
            "L_i": [],
            "L_i_err": [],
            "L_t": [],
            "L_t_err": [],
            "f_r": [],
            "f_r_err": [],
            "photnum": [],
        }

        number_of_power_points = (
            powers.shape[1] if len(powers.shape) > 1 else len(powers)
        )

        for i in range(number_of_power_points):
            for p in np.arange(start, len(freq) // 2, jump):
                # Trim data, unwrap and S21 complex creation
                if p == 0:
                    freq_cut = freq
                    s21_complex_cut = s21_complex
                else:
                    freq_cut = freq[p:-p]
                    s21_complex_cut = s21_complex[p:-p]

                dictio, r = self._resonator_fitter(
                    s21_complex_cut,
                    freq_cut,
                    power=powers[0][i] if len(powers.shape) > 1 else powers[i],
                    bg=bg,
                )

                # Filter out bad fits

                if self._test_fit(r.result, verbose=False, threshold=threshold):
                    dictoflist = dict_filler(dictio, data_store)
                    break

            if savepic:
                a = str(np.mean(freq / 1e9))[:5].replace(".", "_")
                plot_fit(
                    r,
                    save=savepic,
                    savepath=savepath,
                    name=f"{a}GHz_{powers[0][i] if len(powers.shape) > 1 else powers[i]}_dBm",
                    nodialog=nodialog,
                    cut=True,
                    cutted_data={
                        "real": np.real(s21_complex),
                        "imag": np.imag(s21_complex),
                        "phase": phase,
                        "mag": mag,
                        "freq": freq,
                    },
                )
            else:
                plot_fit(
                    r,
                    cut=True,
                    cutted_data={
                        "real": np.real(s21_complex),
                        "imag": np.imag(s21_complex),
                        "phase": phase,
                        "mag": mag,
                        "freq": freq,
                    },
                )
            if write:
                a = str(np.mean(freq / 1e9))[:5].replace(".", "_")
                power_tag = powers[0][i] if len(powers.shape) > 1 else powers[i]
                self._write_fit(
                    dictio,
                    os.path.join(basepath, "Fit results"),
                    name=f"{a}GHz_{power_tag}_dBm",
                    nodialog=nodialog,
                )

        dictofarr = lst_to_arrays(dictoflist)
        return dictofarr

    def _resonator_fitter(
        self,
        data: NDArray,
        freq: NDArray,
        power: Optional[float] = None,
        params: Optional[Parameter] = None,
        fit_method: str = "shunt",
        bg: BackgroundModel = background.MagnitudePhaseDelay(),
        trim_indices: tuple = None,
    ):
        """
        Wrapper around resonator library.

        Parameters
        ----------
        data : NDArray
            Data array of complex values to be fitted.
        freq : NDArray
            Array of frequencies.
        power : float, optional
            Power input in the resonator used to calculate number of photons.
            The default is ``None``.
        params : lmfit.Parameters, optional
            Fit parameters, passed as a lmfit.Parameter object.
        fit_method : str, optional
            Fit method to be used, can be "reflection" or "shunt". The default is "shunt".
        bg : resonator.BackgroundModel, optional
            Background model as defined in the resonator library. The default is
            background.MagnitudePhaseDelay().
        trim_indices : tuple, optional
            Tuple of the form ``(start, end)`` of where to trim the data to fit.
            The default is ``None``.
        """

        if fit_method == "shunt":

            if trim_indices:
                r = shunt.LinearShuntFitter(
                    frequency=freq[trim_indices[0] : -trim_indices[1]],
                    data=data[trim_indices[0] : -trim_indices[1]],
                    params=params,
                    background_model=bg,
                )
            else:
                r = shunt.LinearShuntFitter(
                    frequency=freq, data=data, params=params, background_model=bg
                )

        elif fit_method == "reflection":

            if trim_indices:
                r = reflection.LinearReflectionFitter(
                    frequency=freq[trim_indices[0] : -trim_indices[1]],
                    data=data[trim_indices[0] : -trim_indices[1]],
                    params=params,
                    background_model=bg,
                )
            else:
                r = reflection.LinearReflectionFitter(
                    frequency=freq, data=data, params=params, background_model=bg
                )

        else:
            print("Fit method not recognized")
            return

        if power is not None:
            photon = r.photon_number_from_power(r.f_r, power)
        else:
            photon = 0

        return r, photon

    def _test_fit(self, result, threshold=1, verbose=False):
        """
        Function taken from Nicolas Bourlet (thanks), available on Gitlab of JosePh
        group. Check whether the lmfit result is correct or not.

        Parameters
        ----------
        result : MinimizerResult class object
            Output from lmfit, is the result of a minimization made by lmfit fit functions.
        threshold : float, optional
            A value greater than 0 which determine the error tolerance on fit values. The default is 1 (100%).
        verbose : bool, optional
            If True, displays if the threshold has been reached or if there were no errorbars found. The default is False

        Returns
        -------

        """
        tag = True
        if not result.errorbars:
            tag = False
            if verbose:
                print("No errorbars were calculated")
            return tag

        for param in result.params.values():
            if threshold * abs(param.value) < abs(param.stderr):
                tag = False
                if verbose:
                    print(
                        "Parameter:{} has its error larger than its value".format(
                            param.name
                        )
                    )
        return tag

    def _write_fit(
        self, data: ArrayLike, path: str, filename: str, nodialog: bool = True
    ) -> None:
        """
        Utility function to write the fit results to txt files.
        """
        full_path = os.path.join(path, filename + "_results.txt")

        if os.path.exists(full_path) and not nodialog:
            decision = choice(
                "Overwrite warning", "Text file already exists, overwrite?"
            )

            if not decision:
                return

        with open(full_path, "w") as f:
            f.write(
                filename
                + "\n\n"
                + "------------------------------------------"
                + "\n\n"
            )

            for key, value in data.items():
                f.write(str(key) + " : " + str(value) + "\n\n")

            f.close()
